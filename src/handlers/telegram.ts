/**
 * Telegram Message Handlers
 * 
 * These handlers are called by OpenClaw when messages come from Telegram.
 * OpenClaw handles the Telegram API - we just process the business logic.
 */

import { Services } from '../services';

export interface TelegramUser {
  id: number | string;
  username?: string;
  first_name?: string;
  last_name?: string;
}

export interface TelegramMessage {
  message_id: number;
  from: TelegramUser;
  chat: { id: number; type: string };
  text?: string;
  date: number;
}

/**
 * Handle /start command
 */
export async function handleStart(
  services: Services,
  telegramUser: TelegramUser
): Promise<string> {
  const result = await services.onboarding.handleStart(telegramUser);
  return result.welcomeMessage;
}

/**
 * Handle /help command
 */
export function handleHelp(): string {
  return `**Zaki Commands** ðŸ¤–

**Chat:**
â€¢ Just send a message to chat with your AI
â€¢ /new - Start a fresh conversation

**Agents:**
â€¢ /agents - List your agents
â€¢ /agent create <name> - Create new agent
â€¢ /agent switch <name> - Switch to agent
â€¢ /agent delete <name> - Delete agent

**Settings:**
â€¢ /settings - View your settings
â€¢ /usage - Check your usage stats

**Help:**
â€¢ /help - Show this message
â€¢ /about - About Zaki

Need something else? Just ask!`;
}

/**
 * Handle /agents command
 */
export async function handleAgents(
  services: Services,
  userId: string
): Promise<string> {
  const agents = await services.agent.findByUserId(userId);
  
  if (agents.length === 0) {
    return `You don't have any agents yet. Create one with /agent create <name>`;
  }

  const defaultAgent = agents.find(a => a.isDefault);
  
  const lines = agents.map(a => {
    const marker = a.isDefault ? 'âœ…' : 'â—‹';
    return `${marker} **${a.name}** - ${a.description || 'No description'}`;
  });

  return `**Your Agents** (${agents.length})\n\n${lines.join('\n')}\n\n_Currently using: ${defaultAgent?.name || 'None'}_`;
}

/**
 * Handle /new command - start fresh conversation
 */
export async function handleNewConversation(
  services: Services,
  userId: string
): Promise<string> {
  const agent = await services.agent.getDefaultAgent(userId);
  
  if (!agent) {
    return `No agent found. Use /start to set up.`;
  }

  // Archive current session and create new one
  const currentSession = await services.chat.getOrCreateActiveSession(userId, agent.id);
  await services.chat.archiveSession(currentSession.id);
  
  const newSession = await services.chat.createSession(userId, agent.id);
  
  return `âœ¨ Started a fresh conversation!\n\nWhat would you like to talk about?`;
}

/**
 * Handle /usage command
 */
export async function handleUsage(
  services: Services,
  userId: string
): Promise<string> {
  // TODO: Implement usage tracking query
  return `**Usage Stats** ðŸ“Š

_Coming soon! We're tracking your usage to show you helpful insights._

For now, enjoy unlimited conversations during beta! ðŸŽ‰`;
}

/**
 * Handle regular message (not a command)
 */
export async function handleMessage(
  services: Services,
  telegramUser: TelegramUser,
  text: string
): Promise<{ 
  response: string; 
  context: Array<{ role: string; content: string }>;
  agent: { systemPrompt: string; model: string; provider: string };
  session: { id: string };
}> {
  // Get or create user
  const { user } = await services.user.getOrCreateFromTelegram(telegramUser);
  
  // Get user's active agent
  let agent = await services.agent.getDefaultAgent(user.id);
  
  if (!agent) {
    // Create default agent if none exists
    agent = await services.agent.createDefaultAgent(user.id, telegramUser.first_name);
  }

  // Get or create session
  const session = await services.chat.getOrCreateActiveSession(user.id, agent.id);

  // Save user message
  await services.chat.addMessage({
    sessionId: session.id,
    userId: user.id,
    role: 'user',
    content: text,
  });

  // Build context from conversation history
  const context = await services.chat.buildContext(session.id);

  // Return context and agent info for AI call
  // OpenClaw will handle the actual AI call
  return {
    response: '', // AI response will be generated by OpenClaw
    context,
    agent: {
      systemPrompt: agent.systemPrompt || '',
      model: agent.model || 'claude-sonnet-4-20250514',
      provider: agent.provider || 'anthropic',
    },
    session: {
      id: session.id,
    },
  };
}

/**
 * Save assistant response after AI generates it
 */
export async function saveAssistantResponse(
  services: Services,
  sessionId: string,
  userId: string,
  content: string,
  metadata?: {
    model?: string;
    provider?: string;
    inputTokens?: number;
    outputTokens?: number;
  }
): Promise<void> {
  await services.chat.addMessage({
    sessionId,
    userId,
    role: 'assistant',
    content,
    model: metadata?.model,
    provider: metadata?.provider,
    inputTokens: metadata?.inputTokens,
    outputTokens: metadata?.outputTokens,
  });
}

/**
 * Route incoming message to appropriate handler
 */
export async function routeMessage(
  services: Services,
  message: TelegramMessage
): Promise<string | { needsAI: true; context: any }> {
  const text = message.text?.trim() || '';
  const telegramUser = message.from;

  // Handle commands
  if (text.startsWith('/')) {
    const [command, ...args] = text.slice(1).split(' ');
    
    switch (command.toLowerCase()) {
      case 'start':
        return handleStart(services, telegramUser);
      
      case 'help':
        return handleHelp();
      
      case 'agents':
        const { user } = await services.user.getOrCreateFromTelegram(telegramUser);
        return handleAgents(services, user.id);
      
      case 'new':
        const { user: u } = await services.user.getOrCreateFromTelegram(telegramUser);
        return handleNewConversation(services, u.id);
      
      case 'usage':
        const { user: usr } = await services.user.getOrCreateFromTelegram(telegramUser);
        return handleUsage(services, usr.id);
      
      default:
        return `Unknown command: /${command}\n\nType /help to see available commands.`;
    }
  }

  // Regular message - needs AI processing
  const result = await handleMessage(services, telegramUser, text);
  
  return {
    needsAI: true,
    context: result,
  };
}
